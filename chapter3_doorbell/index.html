<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Doorbell Serialization & The GPU Bottleneck</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        :root {
            --primary: #ef4444;
            --primary-dark: #dc2626;
            --warning: #f59e0b;
            --success: #22c55e;
            --info: #0ea5e9;
            --purple: #a855f7;
            --dark: #1e293b;
            --darker: #0f172a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.7;
            color: var(--dark);
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1f1f 50%, #1a1a2e 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            padding: 4rem 2rem;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(245, 158, 11, 0.2) 100%);
            border-radius: 2rem;
            margin-bottom: 3rem;
            border: 1px solid rgba(239, 68, 68, 0.3);
            backdrop-filter: blur(10px);
        }

        header h1 {
            font-size: 2.8rem;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 0 0 40px rgba(239, 68, 68, 0.5);
        }

        header .subtitle {
            font-size: 1.3rem;
            color: #fca5a5;
            max-width: 900px;
            margin: 0 auto;
        }

        .chapter-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--primary) 0%, var(--warning) 100%);
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 2rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .section {
            background: rgba(30, 41, 59, 0.9);
            border-radius: 1.5rem;
            padding: 2.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(239, 68, 68, 0.2);
            backdrop-filter: blur(10px);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .section-number {
            background: linear-gradient(135deg, var(--primary) 0%, var(--warning) 100%);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.4);
        }

        h2 {
            color: white;
            font-size: 1.8rem;
        }

        h3 {
            color: #fca5a5;
            font-size: 1.4rem;
            margin: 2rem 0 1rem;
        }

        h4 {
            color: #fdba74;
            font-size: 1.1rem;
            margin: 1.5rem 0 0.75rem;
        }

        p {
            color: #cbd5e1;
            margin-bottom: 1rem;
        }

        .highlight {
            color: #fbbf24;
            font-weight: 600;
        }

        .danger {
            color: #f87171;
            font-weight: 600;
        }

        .key-term {
            color: #38bdf8;
            font-weight: 600;
        }

        .diagram-container {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid rgba(239, 68, 68, 0.3);
            overflow: hidden;
        }

        .diagram-title {
            text-align: center;
            color: white;
            font-weight: 600;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
        }

        .diagram-caption {
            text-align: center;
            color: #94a3b8;
            font-size: 0.9rem;
            margin-top: 1rem;
            font-style: italic;
        }

        .code-block {
            background: #0f172a;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            border: 1px solid #334155;
        }

        .code-block code {
            color: #e2e8f0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .keyword { color: #c084fc; }
        .type { color: #22d3ee; }
        .function { color: #fbbf24; }
        .comment { color: #64748b; }
        .number { color: #4ade80; }
        .string { color: #fb923c; }

        .danger-box {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.2) 100%);
            border-left: 4px solid var(--primary);
            border-radius: 0 0.75rem 0.75rem 0;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(234, 179, 8, 0.2) 100%);
            border-left: 4px solid var(--warning);
            border-radius: 0 0.75rem 0.75rem 0;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.2) 0%, rgba(56, 189, 248, 0.2) 100%);
            border-left: 4px solid var(--info);
            border-radius: 0 0.75rem 0.75rem 0;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .slide-figure {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 2rem 0;
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .slide-image {
            width: 100%;
            max-width: 100%;
            border-radius: 0.5rem;
            display: block;
            margin: 0 auto;
        }

        .slide-figure figcaption {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(100, 116, 139, 0.3);
            line-height: 1.6;
        }

        .slide-figure figcaption strong {
            color: #fca5a5;
        }

        .box-title {
            color: white;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 10px 40px rgba(239, 68, 68, 0.3);
        }

        .stat-card.warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
            box-shadow: 0 10px 40px rgba(245, 158, 11, 0.3);
        }

        .stat-card.info {
            background: linear-gradient(135deg, var(--info) 0%, #0284c7 100%);
            box-shadow: 0 10px 40px rgba(14, 165, 233, 0.3);
        }

        .stat-card.success {
            background: linear-gradient(135deg, var(--success) 0%, #16a34a 100%);
            box-shadow: 0 10px 40px rgba(34, 197, 94, 0.3);
        }

        .stat-card.purple {
            background: linear-gradient(135deg, var(--purple) 0%, #7c3aed 100%);
            box-shadow: 0 10px 40px rgba(168, 85, 247, 0.3);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            color: white;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #334155;
        }

        th {
            background: rgba(239, 68, 68, 0.3);
            color: white;
            font-weight: 600;
        }

        td {
            color: #cbd5e1;
        }

        tr:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .comparison-table {
            margin: 2rem 0;
        }

        .comparison-table th:first-child {
            background: rgba(100, 116, 139, 0.3);
        }

        .comparison-table td:nth-child(2) {
            color: #93c5fd;
        }

        .comparison-table td:nth-child(3) {
            color: #86efac;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #334155;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            background: rgba(239, 68, 68, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .nav-link:hover {
            background: rgba(239, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        footer {
            text-align: center;
            padding: 3rem 2rem;
            color: #64748b;
        }

        ul, ol {
            color: #cbd5e1;
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        .timeline {
            position: relative;
            padding-left: 2rem;
            margin: 2rem 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, var(--primary), var(--warning));
        }

        .timeline-item {
            position: relative;
            padding-bottom: 1.5rem;
            padding-left: 1.5rem;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -0.45rem;
            top: 0.5rem;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary);
            border: 2px solid var(--warning);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.95); }
        }

        @keyframes flow {
            from { stroke-dashoffset: 20; }
            to { stroke-dashoffset: 0; }
        }

        @keyframes serialize {
            0% { transform: translateX(0); }
            100% { transform: translateX(10px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="chapter-badge">üö® Chapter 3</div>
            <h1>‚ö° Doorbell Serialization</h1>
            <p class="subtitle">The critical bottleneck: How 200,000+ GPU threads get serialized down to single-threaded doorbell writes, destroying parallel performance</p>
        </header>

        <!-- Section 3.1: The Problem Statement -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.1</div>
                <h2>The Fundamental Mismatch</h2>
            </div>

            <p>GPU computing delivers massive parallelism through hundreds of thousands of concurrent threads. NVMe storage was designed for CPU workloads with tens of cores. When these two worlds collide, the results are catastrophic for performance.</p>

            <div class="stats-grid">
                <div class="stat-card info">
                    <div class="stat-value">270K</div>
                    <div class="stat-label">GPU Threads (H200)</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">132</div>
                    <div class="stat-label">SMs per GPU</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">65K</div>
                    <div class="stat-label">Max NVMe Queues</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">1</div>
                    <div class="stat-label">Doorbell per Queue</div>
                </div>
            </div>

            <div id="mismatch-visualization"></div>

            <div class="danger-box">
                <div class="box-title">üö® The Core Problem</div>
                <p>When multiple GPU threads need to submit I/O to the same NVMe queue, they must <span class="danger">serialize</span> their doorbell writes. This means 32 threads in a warp that could execute in parallel must instead wait in line, one by one.</p>
                <p style="margin-top: 1rem;"><strong>Result:</strong> <span class="danger">32x slowdown</span> just for doorbell writes, plus additional overhead for command ID allocation and completion processing.</p>
            </div>
        </section>

        <!-- Section 3.2: CPU vs GPU I/O Comparison -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.2</div>
                <h2>CPU vs GPU I/O Workload Characteristics</h2>
            </div>

            <p>Understanding the fundamental differences between CPU and GPU I/O patterns reveals why NVMe's design creates bottlenecks for GPU workloads.</p>

            <div id="cpu-gpu-io-comparison"></div>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>CPU-Driven I/O</th>
                        <th>GPU-Driven I/O</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Throughput</strong></td>
                        <td>500MB ‚Äì 1GB/s</td>
                        <td>3-14+ GB/s</td>
                    </tr>
                    <tr>
                        <td><strong>IOPS</strong></td>
                        <td>~1 MIOPS (small blocks)</td>
                        <td>~100 MIOPS potential</td>
                    </tr>
                    <tr>
                        <td><strong>Latency Sensitivity</strong></td>
                        <td>100Œºs - 1ms acceptable</td>
                        <td>Command timeout critical</td>
                    </tr>
                    <tr>
                        <td><strong>Utilization Pattern</strong></td>
                        <td>Continuous</td>
                        <td>Bursty (per batch)</td>
                    </tr>
                    <tr>
                        <td><strong>Use Cases</strong></td>
                        <td>Database, QoS-sensitive apps</td>
                        <td>AI Training, Inference prefill</td>
                    </tr>
                    <tr>
                        <td><strong>Queue Access</strong></td>
                        <td>1 thread per queue</td>
                        <td>1000s of threads per queue</td>
                    </tr>
                </tbody>
            </table>

            <h3>3.2.1 The Queue Contention Problem</h3>

            <div id="queue-contention-demo"></div>
        </section>

        <!-- Section 3.3: Doorbell Mechanics Deep Dive -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.3</div>
                <h2>NVMe Doorbell Mechanics</h2>
            </div>

            <p>To understand the serialization problem, we need to examine exactly what happens when a doorbell is written.</p>

            <h3>3.3.1 What is a Doorbell Write?</h3>

            <p>A <span class="key-term">doorbell</span> is a memory-mapped I/O (MMIO) register in the NVMe controller's BAR0 space. Writing to this register notifies the controller that new commands are available in the submission queue.</p>

            <div class="code-block">
<code><span class="comment">// Doorbell write operation</span>
<span class="keyword">void</span> <span class="function">ring_doorbell</span>(<span class="type">volatile uint32_t</span>* doorbell, <span class="type">uint16_t</span> new_tail) {
    <span class="comment">// This is a PCIe posted write to controller BAR</span>
    *doorbell = new_tail;
    
    <span class="comment">// The write travels through:</span>
    <span class="comment">// 1. GPU memory controller</span>
    <span class="comment">// 2. GPU-to-CPU interconnect (PCIe/NVLink)</span>
    <span class="comment">// 3. CPU memory controller (if CPU in path)</span>
    <span class="comment">// 4. PCIe root complex</span>
    <span class="comment">// 5. PCIe switch (if present)</span>
    <span class="comment">// 6. NVMe controller PCIe endpoint</span>
}
</code>
            </div>

            <h3>3.3.2 The Serialization Points</h3>

            <div id="serialization-points-viz"></div>

            <p>When GPU threads access NVMe queues, they encounter <span class="danger">multiple serialization points</span>:</p>

            <div class="timeline">
                <div class="timeline-item">
                    <h4>1. Command ID Allocation</h4>
                    <p>Each command needs a unique 16-bit ID. Threads must synchronize to avoid duplicates.</p>
                </div>
                <div class="timeline-item">
                    <h4>2. SQ Entry Slot Selection</h4>
                    <p>Threads compete for slots in the submission queue using atomic operations.</p>
                </div>
                <div class="timeline-item">
                    <h4>3. SQ Tail Doorbell Write</h4>
                    <p>Only one thread can write the new tail value. Others must wait.</p>
                </div>
                <div class="timeline-item">
                    <h4>4. CQ Polling</h4>
                    <p>Threads poll the completion queue, competing for cache lines.</p>
                </div>
                <div class="timeline-item">
                    <h4>5. CQ Head Doorbell Write</h4>
                    <p>Again, serialized write to update completion queue head.</p>
                </div>
            </div>
        </section>

        <!-- Section 3.4: The 32-Thread Warp Problem -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.4</div>
                <h2>The 32-Thread Warp Catastrophe</h2>
            </div>

            <p>CUDA executes threads in <span class="key-term">warps of 32 threads</span> using SIMT (Single Instruction, Multiple Thread). When threads in a warp need to perform I/O, the serialization destroys the parallel execution model.</p>

            <div id="thread-sync-slide"></div>

            <div id="warp-serialization-demo"></div>

            <h3>3.4.1 Atomic Operations on GPU</h3>

            <div class="code-block">
<code><span class="comment">// GPU code to submit NVMe command</span>
<span class="keyword">__device__</span> <span class="keyword">void</span> <span class="function">submit_nvme_command</span>(
    <span class="type">NvmeQueue</span>* queue,
    <span class="type">NvmeCommand</span>* cmd
) {
    <span class="comment">// SERIALIZATION POINT 1: Allocate command ID</span>
    <span class="type">uint16_t</span> cmd_id = <span class="function">atomicAdd</span>(&queue->cmd_id_counter, <span class="number">1</span>);
    cmd->command_id = cmd_id;
    
    <span class="comment">// SERIALIZATION POINT 2: Get SQ slot</span>
    <span class="type">uint16_t</span> slot = <span class="function">atomicAdd</span>(&queue->sq_tail, <span class="number">1</span>) % queue->sq_size;
    
    <span class="comment">// Parallel write to SQ (this part is fast)</span>
    queue->sq[slot] = *cmd;
    
    <span class="comment">// Memory fence</span>
    <span class="function">__threadfence_system</span>();
    
    <span class="comment">// SERIALIZATION POINT 3: Ring doorbell</span>
    <span class="comment">// Only ONE thread should do this!</span>
    <span class="keyword">if</span> (<span class="function">threadIdx.x</span> == <span class="number">0</span>) {  <span class="comment">// Leader thread</span>
        *queue->doorbell = queue->sq_tail;
    }
    <span class="function">__syncwarp</span>();  <span class="comment">// Wait for doorbell</span>
}
</code>
            </div>

            <div class="warning-box">
                <div class="box-title">‚ö†Ô∏è The atomicAdd Problem</div>
                <p>When 32 threads in a warp call <code>atomicAdd</code> on the same variable, they execute <span class="danger">serially</span>. The GPU hardware processes one atomic operation at a time for the same memory location.</p>
                <p style="margin-top: 0.5rem;">This means:</p>
                <ul style="margin-top: 0.5rem;">
                    <li>Warp of 32 threads: 32 serial atomic operations</li>
                    <li>SM with 64 warps: 2,048 serial operations</li>
                    <li>GPU with 132 SMs √ó 2,048 threads: potentially millions of serialized ops</li>
                </ul>
            </div>

            <div id="atomic-serialization-viz"></div>
        </section>

        <!-- Section 3.5: Quantifying the Impact -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.5</div>
                <h2>Quantifying the Performance Impact</h2>
            </div>

            <p>Let's calculate the actual performance loss from doorbell serialization.</p>

            <div id="performance-calculator"></div>

            <h3>3.5.1 Theoretical vs Actual Performance</h3>

            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Threads</th>
                        <th>Ideal Time</th>
                        <th>Actual Time</th>
                        <th>Slowdown</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Single Warp I/O</td>
                        <td>32</td>
                        <td>1 cycle</td>
                        <td>32 cycles</td>
                        <td class="danger">32x</td>
                    </tr>
                    <tr>
                        <td>Full SM I/O</td>
                        <td>2,048</td>
                        <td>64 cycles</td>
                        <td>2,048 cycles</td>
                        <td class="danger">32x</td>
                    </tr>
                    <tr>
                        <td>Full GPU I/O</td>
                        <td>270K</td>
                        <td>~8K cycles</td>
                        <td>~270K cycles</td>
                        <td class="danger">32x</td>
                    </tr>
                </tbody>
            </table>

            <h3>3.5.2 Memory and Bandwidth Overhead</h3>

            <div id="overhead-visualization"></div>

            <div class="info-box">
                <div class="box-title">üìä Additional Overhead Per Queue Pair</div>
                <ul>
                    <li><strong>Synchronization memory:</strong> 16 bytes √ó queue depth</li>
                    <li><strong>Command ID tracking:</strong> ~256KB per SSD</li>
                    <li><strong>L1 cache pressure:</strong> Atomic ops evict useful data</li>
                    <li><strong>Warp divergence:</strong> Threads waiting in spin loops</li>
                </ul>
            </div>
        </section>

        <!-- Section 3.6: Why Interrupts Don't Help -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.6</div>
                <h2>Why Interrupts Don't Help GPUs</h2>
            </div>

            <p>NVMe supports MSI-X interrupts for completion notification. However, GPUs cannot use interrupts effectively due to their architecture.</p>

            <div id="interrupt-vs-polling"></div>

            <h3>3.6.1 GPU Architecture Limitations</h3>

            <ul>
                <li><strong>No interrupt handlers:</strong> GPUs are designed for massively parallel computation, not event-driven control</li>
                <li><strong>No hardware support:</strong> No interrupt controller or handler dispatch mechanism</li>
                <li><strong>Context switch cost:</strong> Interrupting GPU computation would require saving massive state</li>
                <li><strong>Software complexity:</strong> No OS kernel running on GPU to handle interrupts</li>
            </ul>

            <h3>3.6.2 Polling is the Only Option</h3>

            <p>GPU threads must <span class="key-term">poll</span> the completion queue, repeatedly reading memory until the phase bit indicates completion.</p>

            <div class="code-block">
<code><span class="comment">// GPU polling loop for NVMe completion</span>
<span class="keyword">__device__</span> <span class="keyword">void</span> <span class="function">wait_for_completion</span>(
    <span class="type">NvmeCQ</span>* cq,
    <span class="type">uint16_t</span> expected_cmd_id
) {
    <span class="type">uint16_t</span> expected_phase = cq->expected_phase;
    
    <span class="comment">// Spin until completion arrives</span>
    <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="comment">// Read completion entry</span>
        <span class="type">NvmeCQE</span> cqe = cq->entries[cq->head];
        
        <span class="comment">// Check phase bit</span>
        <span class="keyword">if</span> ((cqe.status & <span class="number">1</span>) == expected_phase) {
            <span class="comment">// Check if this is our completion</span>
            <span class="keyword">if</span> (cqe.command_id == expected_cmd_id) {
                <span class="keyword">return</span>;  <span class="comment">// Done!</span>
            }
        }
        
        <span class="comment">// Still waiting - burns GPU cycles!</span>
        <span class="comment">// Cannot yield to other work easily</span>
    }
}
</code>
            </div>

            <div class="danger-box">
                <div class="box-title">üî• Polling Burns GPU Resources</div>
                <p>While polling, GPU threads:</p>
                <ul>
                    <li>Consume SM execution slots</li>
                    <li>Generate memory traffic to completion queue</li>
                    <li>Compete for L2 cache with actual compute work</li>
                    <li>Cannot be efficiently context-switched to other work</li>
                </ul>
            </div>
        </section>

        <!-- Section 3.7: Current Solutions and Limitations -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.7</div>
                <h2>Current Solutions and Their Limitations</h2>
            </div>

            <h3>3.7.1 GPUDirect Storage (GDS)</h3>

            <p>NVIDIA's GPUDirect Storage enables direct DMA between NVMe and GPU memory, bypassing CPU. However, it doesn't solve the doorbell serialization problem.</p>

            <div id="gds-architecture"></div>

            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>What GDS Solves</th>
                        <th>What Remains</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Data Path</td>
                        <td>‚úÖ Direct GPU‚ÜîSSD DMA</td>
                        <td>‚Äî</td>
                    </tr>
                    <tr>
                        <td>CPU Bypass</td>
                        <td>‚úÖ No bounce buffer</td>
                        <td>‚Äî</td>
                    </tr>
                    <tr>
                        <td>Control Path</td>
                        <td>‚ùå</td>
                        <td>Still goes through CPU</td>
                    </tr>
                    <tr>
                        <td>Doorbell</td>
                        <td>‚ùå</td>
                        <td>Still serialized</td>
                    </tr>
                    <tr>
                        <td>Queue Management</td>
                        <td>‚ùå</td>
                        <td>CPU manages queues</td>
                    </tr>
                </tbody>
            </table>

            <h3>3.7.2 BaM (Big Accelerator Memory)</h3>

            <p>Research systems like BaM attempt to give GPUs direct access to NVMe queues, but face the same fundamental serialization challenges.</p>

            <h3>3.7.3 Queue Partitioning Strategies</h3>

            <div id="queue-partitioning"></div>
        </section>

        <!-- Section 3.8: The Path Forward -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.8</div>
                <h2>The Path Forward: NVMe Evolution Needed</h2>
            </div>

            <p>Solving the GPU-NVMe impedance mismatch requires fundamental changes to the NVMe protocol. Here are potential directions:</p>

            <h3>3.8.1 Proposed Protocol Changes</h3>

            <div class="info-box">
                <div class="box-title">üí° Potential NVMe Enhancements for GPUs</div>
                <ol>
                    <li><strong>Warp-Aware Queues:</strong> Queue structures aligned to GPU warp size (32 entries)</li>
                    <li><strong>Batched Doorbells:</strong> Single doorbell write for multiple commands</li>
                    <li><strong>Hardware Command ID:</strong> Controller assigns IDs, removing host synchronization</li>
                    <li><strong>In-Order Completion:</strong> Guarantee completion order matches submission order</li>
                    <li><strong>Completion Coalescing:</strong> Reduce completion queue traffic</li>
                </ol>
            </div>

            <h3>3.8.2 Hardware Considerations</h3>

            <ul>
                <li><strong>Doorbell Aggregation:</strong> Hardware to collect doorbell writes and batch to controller</li>
                <li><strong>GPU-Native Queues:</strong> Queue structures in GPU memory format</li>
                <li><strong>Completion Interrupts to GPU:</strong> New mechanism for GPU-aware completion notification</li>
            </ul>

            <div id="future-architecture"></div>

            <div class="warning-box">
                <div class="box-title">‚ö†Ô∏è Industry Action Required</div>
                <p>The NVMe specification committee (NVM Express, Inc.) needs to address GPU workloads as a first-class use case. Current NVMe 2.0 improvements help CPUs but don't address GPU-specific challenges.</p>
            </div>
        </section>

        <!-- Section 3.9: Summary -->
        <section class="section">
            <div class="section-header">
                <div class="section-number">3.9</div>
                <h2>Key Takeaways</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">32x</div>
                    <div class="stat-label">Minimum Slowdown per Warp</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">5</div>
                    <div class="stat-label">Serialization Points</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">0</div>
                    <div class="stat-label">GPU Interrupts Available</div>
                </div>
                <div class="stat-card purple">
                    <div class="stat-value">100M</div>
                    <div class="stat-label">Target IOPS for GPU</div>
                </div>
            </div>

            <h3>The Impedance Mismatch Summary</h3>

            <ol>
                <li><strong>Thread Count Mismatch:</strong> 270K GPU threads vs. tens of CPU cores</li>
                <li><strong>Execution Model Mismatch:</strong> SIMT parallel vs. sequential I/O operations</li>
                <li><strong>Notification Mismatch:</strong> Polling-only vs. interrupt-capable</li>
                <li><strong>Bandwidth Mismatch:</strong> TB/s GPU interconnect vs. GB/s storage</li>
                <li><strong>Latency Hiding Mismatch:</strong> GPU hides memory latency, not I/O latency</li>
            </ol>

            <div class="danger-box">
                <div class="box-title">üéØ Bottom Line</div>
                <p>The NVMe protocol's doorbell-based synchronization model, designed for CPU workloads, creates a fundamental bottleneck when used with GPUs. Until the protocol evolves, GPU-direct storage will remain significantly constrained by serialization overhead.</p>
            </div>
        </section>

        <!-- Navigation -->
        <nav class="nav-links">
            <a href="../chapter2_queues/index.html" class="nav-link">
                ‚Üê Chapter 2: NVMe Queues
            </a>
            <a href="../index.html" class="nav-link">
                üìö Back to Index
            </a>
        </nav>
    </div>

    <footer>
        <p>Chapter 3: Doorbell Serialization | GPU-NVMe Documentation Series</p>
    </footer>

    <!-- React Components -->
    <script type="text/babel">
        // Thread Synchronization Slide (recreated from Industry Analysis)
        const ThreadSyncSlide = () => {
            const [activeSync, setActiveSync] = React.useState(null);
            const [isAnimating, setIsAnimating] = React.useState(true);
            
            React.useEffect(() => {
                if (!isAnimating) return;
                const interval = setInterval(() => {
                    setActiveSync(s => s === null ? 0 : (s + 1) % 6);
                }, 1200);
                return () => clearInterval(interval);
            }, [isAnimating]);

            const syncPoints = [
                { label: 'Threads sync to select a unique and non used NVMe command id', isSync: true },
                { label: 'Write commands in SQ in Parallel', isSync: false },
                { label: 'Threads sync to determine the value to write in the SQ tail doorbell', isSync: true },
                { label: 'Poll the whole CQ in Parallel', isSync: false },
                { label: 'Threads sync to determine the value to write in the CQ head doorbell', isSync: true },
                { label: 'Threads sync to wait for CQ head to pass their completion record position in the CQ', isSync: true },
            ];
            
            return (
                <div style={{background: 'linear-gradient(135deg, #fefce8 0%, #fffbeb 100%)', borderRadius: '1rem', padding: '1.5rem', marginBottom: '2rem', border: '3px solid #eab308', boxShadow: '0 4px 20px rgba(234, 179, 8, 0.2)'}}>
                    {/* Yellow/purple accent bar */}
                    <div style={{display: 'flex'}}>
                        <div style={{width: '6px', background: 'linear-gradient(to bottom, #f59e0b, #eab308, #a855f7)', borderRadius: '3px', marginRight: '1.5rem'}}></div>
                        
                        <div style={{flex: 1}}>
                            {/* Title */}
                            <h3 style={{color: '#7c3aed', fontSize: '1.6rem', fontWeight: '400', marginTop: 0, marginBottom: '1.5rem'}}>
                                Thread Synchronization in NVMe hurts GPU utilization
                            </h3>
                            
                            <div style={{display: 'grid', gridTemplateColumns: '320px 1fr', gap: '1.5rem'}}>
                                {/* LEFT COLUMN */}
                                <div>
                                    {/* NVIDIA H200 */}
                                    <div style={{marginBottom: '1rem'}}>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem'}}>
                                            <div style={{border: '2px solid #1f2937', borderRadius: '4px', padding: '0.3rem 0.6rem', fontSize: '12px', fontWeight: 'bold', color: '#1f2937', background: '#fef3c7'}}>SM<br/>0</div>
                                            <div style={{display: 'flex', flexDirection: 'column'}}>
                                                <span style={{fontWeight: 'bold', color: '#1f2937', fontSize: '13px'}}>Nvidia H200</span>
                                                <span style={{color: '#64748b', fontSize: '11px', borderBottom: '1px dashed #94a3b8'}}>SM - Streaming Multiprocessor</span>
                                            </div>
                                            <div style={{border: '2px solid #1f2937', borderRadius: '4px', padding: '0.3rem 0.6rem', fontSize: '12px', fontWeight: 'bold', color: '#1f2937', background: '#fed7aa'}}>SM<br/>131</div>
                                        </div>
                                        <div style={{display: 'flex', gap: '2rem', marginBottom: '0.5rem', marginLeft: '0.5rem'}}>
                                            <div style={{borderLeft: '2px solid #1f2937', paddingLeft: '0.5rem', fontSize: '11px', color: '#64748b', borderBottom: '1px dashed #94a3b8'}}>2048</div>
                                            <div style={{borderLeft: '2px solid #1f2937', paddingLeft: '0.5rem', fontSize: '11px', color: '#64748b', borderBottom: '1px dashed #94a3b8'}}>2048</div>
                                        </div>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem'}}>
                                            <svg width="30" height="20" viewBox="0 0 30 20">
                                                <polygon points="0,5 25,5 25,0 30,10 25,20 25,15 0,15" fill="#1f2937"/>
                                            </svg>
                                            <span style={{fontSize: '12px', color: '#1f2937'}}>132*2048 = <span style={{textDecoration: 'underline', fontWeight: 'bold'}}>~270K</span> threads in 1 GPU<br/>
                                            <span style={{fontSize: '11px', color: '#64748b'}}>can potentially access NVMe QPs in parallel</span></span>
                                        </div>
                                    </div>
                                    
                                    {/* Many more threads header */}
                                    <div style={{color: '#22c55e', fontSize: '14px', fontWeight: 'bold', marginBottom: '0.5rem'}}>
                                        Many more threads in a GPU than CPU
                                    </div>
                                    
                                    {/* AMD MI325X */}
                                    <div style={{marginBottom: '1rem'}}>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem'}}>
                                            <div style={{border: '2px solid #1f2937', borderRadius: '4px', padding: '0.3rem 0.6rem', fontSize: '12px', fontWeight: 'bold', color: '#1f2937', background: '#fecaca'}}>CU<br/>0</div>
                                            <div style={{display: 'flex', flexDirection: 'column'}}>
                                                <span style={{fontWeight: 'bold', color: '#1f2937', fontSize: '13px'}}>AMD Instinct MI325X</span>
                                                <span style={{color: '#64748b', fontSize: '11px', borderBottom: '1px dashed #94a3b8'}}>CU ‚Äì Compute Unit</span>
                                            </div>
                                            <div style={{border: '2px solid #1f2937', borderRadius: '4px', padding: '0.3rem 0.6rem', fontSize: '12px', fontWeight: 'bold', color: '#1f2937', background: '#fecaca'}}>CU<br/>303</div>
                                        </div>
                                        <div style={{display: 'flex', gap: '2rem', marginBottom: '0.5rem', marginLeft: '0.5rem'}}>
                                            <div style={{borderLeft: '2px solid #1f2937', paddingLeft: '0.5rem', fontSize: '11px', color: '#64748b', borderBottom: '1px dashed #94a3b8'}}>2560</div>
                                            <div style={{borderLeft: '2px solid #1f2937', paddingLeft: '0.5rem', fontSize: '11px', color: '#64748b', borderBottom: '1px dashed #94a3b8'}}>2560</div>
                                        </div>
                                        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem'}}>
                                            <svg width="30" height="20" viewBox="0 0 30 20">
                                                <polygon points="0,5 25,5 25,0 30,10 25,20 25,15 0,15" fill="#1f2937"/>
                                            </svg>
                                            <span style={{fontSize: '12px', fontWeight: 'bold', textDecoration: 'underline', color: '#1f2937'}}>778K</span>
                                            <span style={{fontSize: '12px', color: '#1f2937'}}>threads on 1 AMD GPU</span>
                                        </div>
                                    </div>
                                    
                                    {/* Today vs Future comparison */}
                                    <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.75rem', marginTop: '1rem'}}>
                                        {/* Today - Serial */}
                                        <div style={{background: 'white', borderRadius: '0.5rem', padding: '0.75rem', border: '1px solid #d1d5db'}}>
                                            <div style={{color: '#ef4444', fontSize: '10px', fontStyle: 'italic', marginBottom: '0.5rem', lineHeight: '1.3'}}>
                                                When a thread is in sync code, SM can run only that thread at each cycle
                                            </div>
                                            <div style={{border: '1px solid #22c55e', borderRadius: '4px', padding: '0.5rem', background: '#f0fdf4'}}>
                                                <div style={{fontSize: '9px', color: '#64748b', textAlign: 'center', marginBottom: '0.3rem'}}>32 threads = Warp</div>
                                                <svg viewBox="0 0 100 50" style={{width: '100%', height: '40px'}}>
                                                    {/* Single active thread (red) */}
                                                    <line x1="15" y1="5" x2="15" y2="35" stroke="#ef4444" strokeWidth="3"/>
                                                    <circle cx="15" cy="40" r="4" fill="#ef4444"/>
                                                    {/* Inactive threads (gray) */}
                                                    {[1,2,3,4,5,6,7].map(i => (
                                                        <line key={i} x1={15 + i*12} y1="5" x2={15 + i*12} y2="35" stroke="#9ca3af" strokeWidth="2" opacity="0.5"/>
                                                    ))}
                                                </svg>
                                            </div>
                                            <div style={{background: '#22c55e', color: 'white', textAlign: 'center', padding: '0.25rem', borderRadius: '4px', fontSize: '10px', fontWeight: 'bold', marginTop: '0.5rem'}}>Today</div>
                                        </div>
                                        
                                        {/* Future - Parallel */}
                                        <div style={{background: 'white', borderRadius: '0.5rem', padding: '0.75rem', border: '2px solid #22c55e'}}>
                                            <div style={{color: '#1f2937', fontSize: '10px', marginBottom: '0.5rem', lineHeight: '1.3'}}>
                                                Ideally the SM should run 32 threads at each cycle
                                            </div>
                                            <div style={{border: '1px solid #22c55e', borderRadius: '4px', padding: '0.5rem', background: '#dcfce7'}}>
                                                <div style={{fontSize: '9px', color: '#64748b', textAlign: 'center', marginBottom: '0.3rem'}}>Warp of 32 threads</div>
                                                <svg viewBox="0 0 100 50" style={{width: '100%', height: '40px'}}>
                                                    {/* All threads active with wavy lines */}
                                                    {[0,1,2,3,4,5,6,7].map(i => (
                                                        <React.Fragment key={i}>
                                                            <path d={`M ${12 + i*11} 5 Q ${14 + i*11} 15, ${12 + i*11} 25 Q ${10 + i*11} 35, ${12 + i*11} 40`} 
                                                                  stroke="#22c55e" strokeWidth="2" fill="none"/>
                                                            <polygon points={`${10 + i*11},40 ${12 + i*11},48 ${14 + i*11},40`} fill="#22c55e"/>
                                                        </React.Fragment>
                                                    ))}
                                                </svg>
                                            </div>
                                            <div style={{background: '#22c55e', color: 'white', textAlign: 'center', padding: '0.25rem', borderRadius: '4px', fontSize: '10px', fontWeight: 'bold', marginTop: '0.5rem'}}>Future</div>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* RIGHT COLUMN - Sync Flow */}
                                <div>
                                    {/* Title */}
                                    <div style={{color: '#7c3aed', fontSize: '14px', fontWeight: 'bold', marginBottom: '0.5rem'}}>
                                        Multiple Synchronization points during IO Submission and Completion
                                    </div>
                                    
                                    {/* Description */}
                                    <div style={{color: '#ef4444', fontSize: '11px', marginBottom: '1rem', lineHeight: '1.4'}}>
                                        All threads accessing the same QP go through several synchronization loops (atomic operation+rescheduling, shown in red below) when doing an IO
                                    </div>
                                    
                                    <div style={{display: 'flex', gap: '1rem'}}>
                                        {/* Sync Resources Box */}
                                        <div style={{width: '220px'}}>
                                            <div style={{background: '#4b5563', color: 'white', padding: '0.5rem', borderRadius: '4px 4px 0 0', textAlign: 'center', fontSize: '11px', fontWeight: 'bold'}}>
                                                Synchronization<br/>robs SM resources
                                            </div>
                                            <div style={{background: '#fef3c7', border: '2px solid #f59e0b', borderTop: 'none', borderRadius: '0 0 4px 4px', padding: '0.75rem', fontSize: '10px', lineHeight: '1.5'}}>
                                                <div style={{marginBottom: '0.5rem'}}>
                                                    Synchronizations handled via Loops sleep/ update GPU memory atomic variables.
                                                </div>
                                                <div style={{display: 'flex', alignItems: 'flex-start', gap: '0.3rem', color: '#1f2937', marginBottom: '0.3rem'}}>
                                                    <span style={{color: '#7c3aed'}}>‚Ä∫</span>
                                                    <span>Loss of SM cycles due to thread serialization</span>
                                                </div>
                                                <div style={{display: 'flex', alignItems: 'flex-start', gap: '0.3rem', color: '#1f2937', marginBottom: '0.3rem'}}>
                                                    <span style={{color: '#7c3aed'}}>‚Ä∫</span>
                                                    <span>Impacts SM L1 Cache <span style={{textDecoration: 'underline'}}>bandwidth</span></span>
                                                </div>
                                                <div style={{display: 'flex', alignItems: 'flex-start', gap: '0.3rem', color: '#1f2937', marginBottom: '0.3rem'}}>
                                                    <span style={{color: '#7c3aed'}}>‚Ä∫</span>
                                                    <span>Excessive <span style={{textDecoration: 'underline'}}>re-scheduling</span> of threads (each loop)</span>
                                                </div>
                                                <div style={{display: 'flex', alignItems: 'flex-start', gap: '0.3rem', color: '#1f2937'}}>
                                                    <span style={{color: '#7c3aed'}}>‚Ä∫</span>
                                                    <span><span style={{textDecoration: 'underline'}}>Memory</span> used to synchronize 16*(QP size) per QP + 256KB per SSD</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        {/* Flow Diagram */}
                                        <div style={{flex: 1}}>
                                            {/* Down arrows */}
                                            <div style={{display: 'flex', justifyContent: 'center', gap: '2rem', marginBottom: '0.5rem'}}>
                                                {[0,1,2].map(i => (
                                                    <svg key={i} width="20" height="20" viewBox="0 0 20 20">
                                                        <line x1="10" y1="0" x2="10" y2="15" stroke="#22c55e" strokeWidth="2"/>
                                                        <polygon points="5,12 10,20 15,12" fill="#22c55e"/>
                                                    </svg>
                                                ))}
                                            </div>
                                            
                                            {/* Sync Points Flow */}
                                            <div style={{display: 'flex', flexDirection: 'column', gap: '0.4rem'}}>
                                                {syncPoints.map((point, idx) => (
                                                    <React.Fragment key={idx}>
                                                        <div 
                                                            onClick={() => { setIsAnimating(false); setActiveSync(idx); }}
                                                            style={{
                                                                background: point.isSync 
                                                                    ? (activeSync === idx ? '#fecaca' : '#fee2e2')
                                                                    : (activeSync === idx ? '#86efac' : '#22c55e'),
                                                                color: point.isSync ? '#1f2937' : 'white',
                                                                border: point.isSync ? '1px solid #fca5a5' : 'none',
                                                                borderRadius: '4px',
                                                                padding: '0.5rem 0.75rem',
                                                                fontSize: '11px',
                                                                fontWeight: point.isSync ? 'normal' : 'bold',
                                                                cursor: 'pointer',
                                                                transition: 'all 0.3s',
                                                                transform: activeSync === idx ? 'scale(1.02)' : 'scale(1)',
                                                                boxShadow: activeSync === idx ? '0 2px 8px rgba(0,0,0,0.15)' : 'none'
                                                            }}
                                                        >
                                                            {point.label}
                                                        </div>
                                                        {idx < syncPoints.length - 1 && (
                                                            <div style={{display: 'flex', justifyContent: 'center', gap: '2rem'}}>
                                                                {[0,1,2].map(i => (
                                                                    <svg key={i} width="10" height="12" viewBox="0 0 10 12">
                                                                        <line x1="5" y1="0" x2="5" y2="8" stroke="#22c55e" strokeWidth="2"/>
                                                                        <polygon points="2,6 5,12 8,6" fill="#22c55e"/>
                                                                    </svg>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </React.Fragment>
                                                ))}
                                            </div>
                                        </div>
                                        
                                        {/* IO Labels on right side */}
                                        <div style={{display: 'flex', flexDirection: 'column', justifyContent: 'space-between', paddingTop: '2rem', paddingBottom: '1rem'}}>
                                            <div style={{color: '#1f2937', fontSize: '12px', fontWeight: 'bold', textAlign: 'right'}}>
                                                IO<br/>Submission
                                            </div>
                                            <div style={{color: '#1f2937', fontSize: '12px', fontWeight: 'bold', textAlign: 'right'}}>
                                                IO<br/>Completion
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Bottom blue callout */}
                            <div style={{
                                background: '#0891b2',
                                borderRadius: '0.5rem',
                                padding: '1rem 2rem',
                                marginTop: '1.5rem',
                                textAlign: 'center',
                                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.2)'
                            }}>
                                <p style={{margin: 0, color: 'white', fontSize: '1rem', fontWeight: '500'}}>
                                    NVMe Protocol revisions can reduce sync points, improve parallelization and improve GPU utilization
                                </p>
                            </div>
                            
                            {/* Footer */}
                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem', paddingTop: '0.75rem', borderTop: '1px solid #e5e7eb'}}>
                                <div style={{color: '#64748b', fontSize: '11px'}}>20 | ¬©2025 Industry Developer Conference. All Rights Reserved.</div>
                                <div style={{display: 'flex', alignItems: 'center', gap: '1rem'}}>
                                    <span style={{color: '#1f2937', fontWeight: 'bold', fontSize: '14px', fontFamily: 'Arial, sans-serif'}}>Industry</span>
                                    <div style={{background: '#7c3aed', color: 'white', padding: '0.2rem 0.5rem', borderRadius: '4px', fontSize: '11px', fontWeight: 'bold'}}>Industry 25</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Mismatch Visualization
        const MismatchVisualization = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">The GPU-NVMe Impedance Mismatch</div>
                    <svg viewBox="0 0 800 350" style={{width: '100%', maxWidth: '800px', margin: '0 auto', display: 'block'}}>
                        {/* GPU Side */}
                        <g transform="translate(50, 30)">
                            <rect width="280" height="280" fill="rgba(34, 197, 94, 0.1)" rx="12" stroke="#22c55e" strokeWidth="2"/>
                            <text x="140" y="30" textAnchor="middle" fill="#22c55e" fontWeight="bold" fontSize="16">GPU (H200)</text>
                            
                            {/* Thread blocks */}
                            <text x="140" y="55" textAnchor="middle" fill="#94a3b8" fontSize="11">270,000 Concurrent Threads</text>
                            
                            {/* Visual threads */}
                            {[...Array(12)].map((_, row) => (
                                [...Array(20)].map((_, col) => (
                                    <rect key={`${row}-${col}`} 
                                          x={20 + col * 13} y={70 + row * 16} 
                                          width="10" height="12" 
                                          fill="#22c55e" rx="1" opacity="0.7"/>
                                ))
                            ))}
                            
                            <text x="140" y="280" textAnchor="middle" fill="#64748b" fontSize="10">
                                Each dot = ~1000 threads
                            </text>
                        </g>
                        
                        {/* Funnel */}
                        <g transform="translate(350, 80)">
                            <path d="M 0 0 L 100 0 L 70 180 L 30 180 Z" fill="rgba(239, 68, 68, 0.3)" stroke="#ef4444" strokeWidth="2"/>
                            <text x="50" y="90" textAnchor="middle" fill="white" fontWeight="bold" fontSize="12">SERIALIZE</text>
                            <text x="50" y="110" textAnchor="middle" fill="#f87171" fontSize="10">Doorbell</text>
                            <text x="50" y="125" textAnchor="middle" fill="#f87171" fontSize="10">Bottleneck</text>
                        </g>
                        
                        {/* NVMe Side */}
                        <g transform="translate(470, 30)">
                            <rect width="280" height="280" fill="rgba(14, 165, 233, 0.1)" rx="12" stroke="#0ea5e9" strokeWidth="2"/>
                            <text x="140" y="30" textAnchor="middle" fill="#0ea5e9" fontWeight="bold" fontSize="16">NVMe SSD</text>
                            
                            <text x="140" y="55" textAnchor="middle" fill="#94a3b8" fontSize="11">~100 Queue Pairs Active</text>
                            
                            {/* Queues */}
                            {[...Array(10)].map((_, i) => (
                                <g key={i} transform={`translate(${30 + (i % 5) * 50}, ${80 + Math.floor(i / 5) * 80})`}>
                                    <rect width="40" height="60" fill="#1e293b" rx="4" stroke="#0ea5e9"/>
                                    <text x="20" y="35" textAnchor="middle" fill="#7dd3fc" fontSize="9">QP{i}</text>
                                </g>
                            ))}
                            
                            <text x="140" y="260" textAnchor="middle" fill="#64748b" fontSize="10">
                                1 doorbell per queue = serialization
                            </text>
                        </g>
                        
                        {/* Arrows showing flow */}
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444"/>
                            </marker>
                        </defs>
                        
                        <line x1="330" y1="170" x2="345" y2="170" stroke="#ef4444" strokeWidth="3" markerEnd="url(#arrowhead)"/>
                        <line x1="455" y1="170" x2="470" y2="170" stroke="#ef4444" strokeWidth="3" markerEnd="url(#arrowhead)"/>
                        
                        {/* Stats */}
                        <text x="400" y="330" textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">
                            270,000 threads ‚Üí 100 queues ‚Üí <tspan fill="#ef4444">2,700 threads per doorbell!</tspan>
                        </text>
                    </svg>
                </div>
            );
        };

        // CPU vs GPU I/O Comparison
        const CPUGPUIOComparison = () => {
            const [selected, setSelected] = React.useState('cpu');
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">I/O Access Pattern Comparison</div>
                    <div style={{display: 'flex', justifyContent: 'center', gap: '1rem', marginBottom: '1.5rem'}}>
                        <button onClick={() => setSelected('cpu')} style={{
                            padding: '0.75rem 2rem', borderRadius: '0.5rem', border: 'none',
                            background: selected === 'cpu' ? '#3b82f6' : '#334155', 
                            color: 'white', cursor: 'pointer', fontWeight: '600'
                        }}>
                            CPU Pattern
                        </button>
                        <button onClick={() => setSelected('gpu')} style={{
                            padding: '0.75rem 2rem', borderRadius: '0.5rem', border: 'none',
                            background: selected === 'gpu' ? '#22c55e' : '#334155', 
                            color: 'white', cursor: 'pointer', fontWeight: '600'
                        }}>
                            GPU Pattern
                        </button>
                    </div>
                    
                    <svg viewBox="0 0 700 300" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {selected === 'cpu' ? (
                            <g>
                                {/* CPU - Few cores, dedicated queues */}
                                <text x="350" y="25" textAnchor="middle" fill="#3b82f6" fontWeight="bold" fontSize="14">
                                    CPU: 1 Queue per Core (No Contention)
                                </text>
                                
                                {[0,1,2,3].map(i => (
                                    <g key={i} transform={`translate(${100 + i * 140}, 40)`}>
                                        <rect width="100" height="50" fill="#3b82f6" rx="8"/>
                                        <text x="50" y="30" textAnchor="middle" fill="white" fontSize="11">Core {i}</text>
                                        
                                        <line x1="50" y1="50" x2="50" y2="80" stroke="#22c55e" strokeWidth="2"/>
                                        
                                        <rect y="80" width="100" height="80" fill="#1e293b" rx="8" stroke="#22c55e"/>
                                        <text x="50" y="105" textAnchor="middle" fill="#22c55e" fontSize="10">Queue {i}</text>
                                        <text x="50" y="125" textAnchor="middle" fill="#64748b" fontSize="9">Dedicated</text>
                                        <text x="50" y="145" textAnchor="middle" fill="#64748b" fontSize="9">No waiting!</text>
                                    </g>
                                ))}
                                
                                <text x="350" y="200" textAnchor="middle" fill="#22c55e" fontSize="12">
                                    ‚úì Each core has exclusive queue access
                                </text>
                                <text x="350" y="220" textAnchor="middle" fill="#22c55e" fontSize="12">
                                    ‚úì No synchronization needed
                                </text>
                                <text x="350" y="240" textAnchor="middle" fill="#22c55e" fontSize="12">
                                    ‚úì Interrupts for completion notification
                                </text>
                                
                                {/* Timeline */}
                                <rect x="50" y="260" width="600" height="25" fill="rgba(59, 130, 246, 0.3)" rx="6"/>
                                <text x="350" y="277" textAnchor="middle" fill="white" fontSize="11">
                                    Continuous, steady I/O stream (~1M IOPS)
                                </text>
                            </g>
                        ) : (
                            <g>
                                {/* GPU - Many threads, shared queues */}
                                <text x="350" y="25" textAnchor="middle" fill="#22c55e" fontWeight="bold" fontSize="14">
                                    GPU: Thousands of Threads per Queue (Massive Contention!)
                                </text>
                                
                                {/* Thread visualization */}
                                <g transform="translate(50, 40)">
                                    <rect width="250" height="60" fill="rgba(34, 197, 94, 0.2)" rx="8" stroke="#22c55e"/>
                                    <text x="125" y="20" textAnchor="middle" fill="#22c55e" fontSize="11">2,048+ Threads (per SM)</text>
                                    {[...Array(40)].map((_, i) => (
                                        <rect key={i} x={10 + (i % 20) * 12} y={30 + Math.floor(i / 20) * 15} 
                                              width="8" height="10" fill="#22c55e" rx="1"/>
                                    ))}
                                </g>
                                
                                {/* Funnel to single queue */}
                                <path d="M 175 100 L 175 130 L 125 160 L 225 160 Z" fill="rgba(239, 68, 68, 0.3)" stroke="#ef4444"/>
                                <text x="175" y="145" textAnchor="middle" fill="white" fontSize="9">SERIALIZE</text>
                                
                                {/* Single queue */}
                                <g transform="translate(125, 165)">
                                    <rect width="100" height="60" fill="#1e293b" rx="8" stroke="#ef4444" strokeWidth="2"/>
                                    <text x="50" y="25" textAnchor="middle" fill="#ef4444" fontSize="10">Queue</text>
                                    <text x="50" y="45" textAnchor="middle" fill="#f87171" fontSize="9">BOTTLENECK</text>
                                </g>
                                
                                {/* Problem indicators */}
                                <g transform="translate(350, 60)">
                                    <text fill="#ef4444" fontSize="11">‚úó 2000+ threads fight for 1 doorbell</text>
                                    <text y="20" fill="#ef4444" fontSize="11">‚úó Atomic operations serialize</text>
                                    <text y="40" fill="#ef4444" fontSize="11">‚úó No interrupts - must poll</text>
                                    <text y="60" fill="#ef4444" fontSize="11">‚úó Bursty pattern amplifies contention</text>
                                </g>
                                
                                {/* Bursty timeline */}
                                <g transform="translate(50, 250)">
                                    <rect width="600" height="30" fill="rgba(15, 23, 42, 0.8)" rx="6"/>
                                    <rect x="50" y="5" width="80" height="20" fill="#22c55e" rx="3"/>
                                    <rect x="200" y="5" width="80" height="20" fill="#22c55e" rx="3"/>
                                    <rect x="380" y="5" width="80" height="20" fill="#22c55e" rx="3"/>
                                    <rect x="520" y="5" width="60" height="20" fill="#22c55e" rx="3"/>
                                    <text x="300" y="47" textAnchor="middle" fill="#94a3b8" fontSize="10">
                                        Bursty I/O pattern (per batch) - peaks at 100M+ IOPS demand
                                    </text>
                                </g>
                            </g>
                        )}
                    </svg>
                </div>
            );
        };

        // Queue Contention Demo
        const QueueContentionDemo = () => {
            const [threads, setThreads] = React.useState([]);
            const [isRunning, setIsRunning] = React.useState(false);
            const [completedCount, setCompletedCount] = React.useState(0);
            
            React.useEffect(() => {
                if (isRunning && threads.length < 32) {
                    const interval = setInterval(() => {
                        setThreads(prev => [...prev, prev.length]);
                        setCompletedCount(c => c + 1);
                    }, 150);
                    return () => clearInterval(interval);
                } else if (threads.length >= 32) {
                    setIsRunning(false);
                    setThreads([]);
                }
            }, [isRunning, threads]);
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">32-Thread Warp Competing for Single Doorbell</div>
                    <div style={{display: 'flex', justifyContent: 'center', gap: '1rem', marginBottom: '1rem'}}>
                        <button onClick={() => {setIsRunning(true); setThreads([]); setCompletedCount(0);}} style={{
                            padding: '0.5rem 1.5rem', borderRadius: '0.5rem', border: 'none',
                            background: '#22c55e', color: 'white', cursor: 'pointer', fontWeight: '600'
                        }}>
                            ‚ñ∂ Start Warp I/O
                        </button>
                    </div>
                    
                    <svg viewBox="0 0 700 250" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* 32 threads waiting */}
                        <text x="200" y="20" textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">Warp (32 Threads)</text>
                        {[...Array(32)].map((_, i) => (
                            <rect key={i} 
                                  x={20 + (i % 16) * 24} 
                                  y={30 + Math.floor(i / 16) * 35}
                                  width="20" height="28"
                                  fill={threads.includes(i) ? '#22c55e' : i === threads.length ? '#fbbf24' : '#334155'}
                                  rx="3"
                                  stroke={i === threads.length ? '#fbbf24' : 'none'}
                                  strokeWidth="2"/>
                        ))}
                        
                        {/* Funnel */}
                        <path d="M 420 40 L 480 40 L 460 100 L 440 100 Z" fill="rgba(239, 68, 68, 0.3)" stroke="#ef4444" strokeWidth="2"/>
                        
                        {/* Single doorbell */}
                        <rect x="430" y="110" width="40" height="40" fill="#ef4444" rx="8"/>
                        <text x="450" y="135" textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">DB</text>
                        
                        {/* Progress indicator */}
                        <text x="550" y="70" fill="white" fontSize="12">Completed: {completedCount}/32</text>
                        <rect x="550" y="80" width="100" height="15" fill="#1e293b" rx="4"/>
                        <rect x="550" y="80" width={completedCount * 100 / 32} height="15" fill="#22c55e" rx="4"/>
                        
                        {/* Time comparison */}
                        <g transform="translate(420, 170)">
                            <text fill="white" fontSize="11" fontWeight="bold">Time to complete:</text>
                            <text y="20" fill="#22c55e" fontSize="10">Ideal (parallel):</text>
                            <rect x="120" y="10" width="30" height="12" fill="#22c55e" rx="2"/>
                            <text x="160" y="20" fill="#64748b" fontSize="10">1 cycle</text>
                            
                            <text y="40" fill="#ef4444" fontSize="10">Actual (serial):</text>
                            <rect x="120" y="30" width={Math.min(completedCount * 5, 150)} height="12" fill="#ef4444" rx="2"/>
                            <text x="280" y="40" fill="#64748b" fontSize="10">{completedCount} cycles</text>
                        </g>
                        
                        {/* Labels */}
                        <text x="200" y="120" textAnchor="middle" fill="#94a3b8" fontSize="10">
                            {isRunning ? `Thread ${threads.length} writing doorbell...` : 'Click Start to simulate'}
                        </text>
                    </svg>
                    <div className="diagram-caption">
                        Only ONE thread can write the doorbell at a time. 32 threads = 32 serial writes.
                    </div>
                </div>
            );
        };

        // Serialization Points Visualization
        const SerializationPointsViz = () => {
            const [activePoint, setActivePoint] = React.useState(null);
            
            const points = [
                { id: 1, name: 'Command ID Alloc', x: 100, desc: 'atomicAdd for unique ID' },
                { id: 2, name: 'SQ Slot Select', x: 220, desc: 'atomicAdd for queue slot' },
                { id: 3, name: 'SQ Doorbell', x: 340, desc: 'Single writer to MMIO' },
                { id: 4, name: 'CQ Polling', x: 460, desc: 'Threads poll same cache line' },
                { id: 5, name: 'CQ Doorbell', x: 580, desc: 'Single writer to MMIO' },
            ];
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">Five Serialization Points in GPU NVMe I/O</div>
                    <svg viewBox="0 0 700 200" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* Timeline */}
                        <line x1="50" y1="80" x2="650" y2="80" stroke="#334155" strokeWidth="3"/>
                        
                        {/* Points */}
                        {points.map((point, i) => (
                            <g key={point.id} 
                               style={{cursor: 'pointer'}}
                               onMouseEnter={() => setActivePoint(point.id)}
                               onMouseLeave={() => setActivePoint(null)}>
                                <circle cx={point.x} cy="80" r="20" 
                                        fill={activePoint === point.id ? '#ef4444' : '#1e293b'}
                                        stroke="#ef4444" strokeWidth="2"/>
                                <text x={point.x} y="85" textAnchor="middle" fill="white" fontSize="14" fontWeight="bold">
                                    {point.id}
                                </text>
                                <text x={point.x} y="120" textAnchor="middle" fill="#fca5a5" fontSize="9">
                                    {point.name}
                                </text>
                                {activePoint === point.id && (
                                    <g>
                                        <rect x={point.x - 60} y="135" width="120" height="25" fill="#ef4444" rx="4"/>
                                        <text x={point.x} y="152" textAnchor="middle" fill="white" fontSize="9">
                                            {point.desc}
                                        </text>
                                    </g>
                                )}
                            </g>
                        ))}
                        
                        {/* Arrows between points */}
                        {[0,1,2,3].map(i => (
                            <line key={i} x1={points[i].x + 25} y1="80" x2={points[i+1].x - 25} y2="80" 
                                  stroke="#f87171" strokeWidth="2" strokeDasharray="5,3"/>
                        ))}
                        
                        {/* Legend */}
                        <text x="350" y="30" textAnchor="middle" fill="#94a3b8" fontSize="11">
                            Hover over each point to see the serialization cause
                        </text>
                    </svg>
                </div>
            );
        };

        // Warp Serialization Demo
        const WarpSerializationDemo = () => {
            const [step, setStep] = React.useState(0);
            const [isPlaying, setIsPlaying] = React.useState(false);
            
            React.useEffect(() => {
                if (isPlaying) {
                    const interval = setInterval(() => {
                        setStep(prev => (prev + 1) % 33);
                    }, 200);
                    return () => clearInterval(interval);
                }
            }, [isPlaying]);
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">SIMT Execution vs Serialized Doorbell</div>
                    <div style={{display: 'flex', justifyContent: 'center', gap: '1rem', marginBottom: '1rem'}}>
                        <button onClick={() => setIsPlaying(!isPlaying)} style={{
                            padding: '0.5rem 1.5rem', borderRadius: '0.5rem', border: 'none',
                            background: isPlaying ? '#ef4444' : '#22c55e', color: 'white', cursor: 'pointer', fontWeight: '600'
                        }}>
                            {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
                        </button>
                        <button onClick={() => setStep(0)} style={{
                            padding: '0.5rem 1.5rem', borderRadius: '0.5rem', border: '1px solid #64748b',
                            background: 'transparent', color: '#94a3b8', cursor: 'pointer'
                        }}>
                            Reset
                        </button>
                    </div>
                    
                    <svg viewBox="0 0 800 300" style={{width: '100%', maxWidth: '800px', margin: '0 auto', display: 'block'}}>
                        {/* Ideal (parallel) */}
                        <g transform="translate(50, 30)">
                            <text x="150" y="0" textAnchor="middle" fill="#22c55e" fontWeight="bold" fontSize="12">
                                Ideal: Parallel Execution
                            </text>
                            <rect x="0" y="10" width="300" height="80" fill="rgba(34, 197, 94, 0.1)" rx="8" stroke="#22c55e"/>
                            
                            {/* All threads execute together */}
                            {[...Array(32)].map((_, i) => (
                                <rect key={i} x={10 + (i % 16) * 18} y={20 + Math.floor(i / 16) * 35}
                                      width="14" height="28"
                                      fill={step >= 1 ? '#22c55e' : '#334155'} rx="2"/>
                            ))}
                            <text x="150" y="100" textAnchor="middle" fill="#64748b" fontSize="10">
                                All 32 threads complete in 1 cycle
                            </text>
                        </g>
                        
                        {/* Actual (serial) */}
                        <g transform="translate(400, 30)">
                            <text x="175" y="0" textAnchor="middle" fill="#ef4444" fontWeight="bold" fontSize="12">
                                Actual: Serial Doorbell Write
                            </text>
                            <rect x="0" y="10" width="350" height="80" fill="rgba(239, 68, 68, 0.1)" rx="8" stroke="#ef4444"/>
                            
                            {/* Threads complete one at a time */}
                            {[...Array(32)].map((_, i) => (
                                <rect key={i} x={10 + (i % 16) * 21} y={20 + Math.floor(i / 16) * 35}
                                      width="17" height="28"
                                      fill={i < step ? '#22c55e' : i === step ? '#fbbf24' : '#334155'} rx="2"/>
                            ))}
                            <text x="175" y="100" textAnchor="middle" fill="#64748b" fontSize="10">
                                Thread {Math.min(step, 31)} / 32 - Takes 32 cycles!
                            </text>
                        </g>
                        
                        {/* Time comparison bars */}
                        <g transform="translate(50, 150)">
                            <text fill="white" fontSize="12" fontWeight="bold">Execution Time Comparison</text>
                            
                            <text y="30" fill="#22c55e" fontSize="11">Ideal:</text>
                            <rect x="80" y="18" width="50" height="18" fill="#22c55e" rx="3"/>
                            <text x="140" y="32" fill="#64748b" fontSize="10">1 cycle</text>
                            
                            <text y="60" fill="#ef4444" fontSize="11">Actual:</text>
                            <rect x="80" y="48" width={Math.min(step * 20 + 10, 640)} height="18" fill="#ef4444" rx="3"/>
                            <text x={Math.min(step * 20 + 100, 650)} y="62" fill="#64748b" fontSize="10">{step} cycles</text>
                        </g>
                        
                        {/* Slowdown indicator */}
                        <g transform="translate(50, 220)">
                            <rect width="700" height="50" fill="rgba(239, 68, 68, 0.2)" rx="8"/>
                            <text x="350" y="30" textAnchor="middle" fill="white" fontSize="14" fontWeight="bold">
                                Slowdown: <tspan fill="#ef4444" fontSize="20">{step || 1}x</tspan>
                                {step >= 32 && <tspan fill="#fbbf24"> (32x when complete!)</tspan>}
                            </text>
                        </g>
                    </svg>
                </div>
            );
        };

        // Atomic Serialization Visualization
        const AtomicSerializationViz = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">GPU Atomic Operations Serialize at Same Address</div>
                    <svg viewBox="0 0 700 250" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* Multiple warps */}
                        <text x="100" y="20" textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">Multiple Warps</text>
                        {[0, 1, 2].map(w => (
                            <g key={w} transform={`translate(20, ${35 + w * 55})`}>
                                <rect width="160" height="45" fill="rgba(34, 197, 94, 0.2)" rx="6" stroke="#22c55e"/>
                                <text x="80" y="15" textAnchor="middle" fill="#22c55e" fontSize="10">Warp {w}</text>
                                {[...Array(8)].map((_, t) => (
                                    <rect key={t} x={5 + t * 19} y={22} width="15" height="18" fill="#22c55e" rx="2"/>
                                ))}
                            </g>
                        ))}
                        
                        {/* Atomic operation flow */}
                        <g transform="translate(200, 40)">
                            <path d="M 0 60 Q 50 60 80 100" stroke="#fbbf24" strokeWidth="2" fill="none" strokeDasharray="5,3"/>
                            <path d="M 0 115 L 80 115" stroke="#fbbf24" strokeWidth="2" fill="none" strokeDasharray="5,3"/>
                            <path d="M 0 170 Q 50 170 80 130" stroke="#fbbf24" strokeWidth="2" fill="none" strokeDasharray="5,3"/>
                        </g>
                        
                        {/* Single memory location */}
                        <g transform="translate(290, 80)">
                            <rect width="120" height="70" fill="#ef4444" rx="8"/>
                            <text x="60" y="25" textAnchor="middle" fill="white" fontSize="11" fontWeight="bold">atomicAdd</text>
                            <text x="60" y="45" textAnchor="middle" fill="white" fontSize="10">&queue->tail</text>
                            <text x="60" y="60" textAnchor="middle" fill="#fca5a5" fontSize="9">ONE AT A TIME</text>
                        </g>
                        
                        {/* Serial execution timeline */}
                        <g transform="translate(430, 40)">
                            <text fill="white" fontSize="11" fontWeight="bold">Execution Order:</text>
                            {[...Array(8)].map((_, i) => (
                                <g key={i} transform={`translate(0, ${20 + i * 22})`}>
                                    <rect width="200" height="18" fill={`hsl(${120 - i * 15}, 70%, 40%)`} rx="3"/>
                                    <text x="100" y="13" textAnchor="middle" fill="white" fontSize="9">
                                        Thread {i} atomic (cycle {i + 1})
                                    </text>
                                </g>
                            ))}
                            <text y="200" fill="#94a3b8" fontSize="9">...continues for all threads</text>
                        </g>
                        
                        {/* Result */}
                        <text x="350" y="240" textAnchor="middle" fill="#f87171" fontSize="11">
                            96 threads across 3 warps = 96 serial atomic operations
                        </text>
                    </svg>
                </div>
            );
        };

        // Performance Calculator
        const PerformanceCalculator = () => {
            const [threadsPerWarp] = React.useState(32);
            const [warpsPerSM, setWarpsPerSM] = React.useState(64);
            const [numSMs, setNumSMs] = React.useState(132);
            const [queues, setQueues] = React.useState(100);
            
            const totalThreads = threadsPerWarp * warpsPerSM * numSMs;
            const threadsPerQueue = Math.ceil(totalThreads / queues);
            const serialCycles = threadsPerQueue;
            const idealCycles = Math.ceil(threadsPerQueue / 32);
            const slowdown = Math.round(serialCycles / idealCycles);
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">Interactive Performance Impact Calculator</div>
                    <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem', marginBottom: '1.5rem'}}>
                        <div>
                            <label style={{color: '#94a3b8', fontSize: '0.9rem'}}>Warps per SM</label>
                            <input type="range" min="32" max="64" value={warpsPerSM} 
                                   onChange={(e) => setWarpsPerSM(Number(e.target.value))}
                                   style={{width: '100%'}}/>
                            <span style={{color: 'white'}}>{warpsPerSM}</span>
                        </div>
                        <div>
                            <label style={{color: '#94a3b8', fontSize: '0.9rem'}}>Number of SMs</label>
                            <input type="range" min="50" max="200" value={numSMs} 
                                   onChange={(e) => setNumSMs(Number(e.target.value))}
                                   style={{width: '100%'}}/>
                            <span style={{color: 'white'}}>{numSMs}</span>
                        </div>
                        <div>
                            <label style={{color: '#94a3b8', fontSize: '0.9rem'}}>NVMe Queues</label>
                            <input type="range" min="10" max="500" value={queues} 
                                   onChange={(e) => setQueues(Number(e.target.value))}
                                   style={{width: '100%'}}/>
                            <span style={{color: 'white'}}>{queues}</span>
                        </div>
                    </div>
                    
                    <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem', textAlign: 'center'}}>
                        <div style={{background: 'rgba(14, 165, 233, 0.2)', padding: '1rem', borderRadius: '0.5rem'}}>
                            <div style={{fontSize: '1.5rem', fontWeight: 'bold', color: '#7dd3fc'}}>{totalThreads.toLocaleString()}</div>
                            <div style={{color: '#94a3b8', fontSize: '0.85rem'}}>Total GPU Threads</div>
                        </div>
                        <div style={{background: 'rgba(245, 158, 11, 0.2)', padding: '1rem', borderRadius: '0.5rem'}}>
                            <div style={{fontSize: '1.5rem', fontWeight: 'bold', color: '#fbbf24'}}>{threadsPerQueue.toLocaleString()}</div>
                            <div style={{color: '#94a3b8', fontSize: '0.85rem'}}>Threads per Queue</div>
                        </div>
                        <div style={{background: 'rgba(239, 68, 68, 0.2)', padding: '1rem', borderRadius: '0.5rem'}}>
                            <div style={{fontSize: '1.5rem', fontWeight: 'bold', color: '#f87171'}}>{slowdown}x</div>
                            <div style={{color: '#94a3b8', fontSize: '0.85rem'}}>Slowdown Factor</div>
                        </div>
                    </div>
                </div>
            );
        };

        // Overhead Visualization  
        const OverheadVisualization = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">Memory & Cache Overhead from Synchronization</div>
                    <svg viewBox="0 0 700 200" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* Memory breakdown */}
                        <g transform="translate(50, 30)">
                            <text fill="white" fontSize="12" fontWeight="bold">Per-Queue Memory Overhead</text>
                            
                            <rect y="20" width="150" height="25" fill="#3b82f6" rx="4"/>
                            <text x="75" y="37" textAnchor="middle" fill="white" fontSize="10">SQ: 64B √ó depth</text>
                            
                            <rect y="50" width="80" height="25" fill="#a855f7" rx="4"/>
                            <text x="40" y="67" textAnchor="middle" fill="white" fontSize="10">CQ: 16B √ó depth</text>
                            
                            <rect y="80" width="200" height="25" fill="#ef4444" rx="4"/>
                            <text x="100" y="97" textAnchor="middle" fill="white" fontSize="10">Sync metadata: 16B √ó depth</text>
                            
                            <rect y="110" width="120" height="25" fill="#f59e0b" rx="4"/>
                            <text x="60" y="127" textAnchor="middle" fill="white" fontSize="10">Cmd ID tracking</text>
                        </g>
                        
                        {/* Cache impact */}
                        <g transform="translate(350, 30)">
                            <text fill="white" fontSize="12" fontWeight="bold">L1 Cache Impact</text>
                            
                            <rect y="20" width="300" height="30" fill="#1e293b" rx="4" stroke="#64748b"/>
                            <text x="150" y="40" textAnchor="middle" fill="#64748b" fontSize="10">L1 Cache (128KB)</text>
                            
                            {/* Cache line contention */}
                            <rect x="10" y="60" width="80" height="20" fill="#22c55e" rx="3"/>
                            <text x="50" y="74" textAnchor="middle" fill="white" fontSize="8">Useful data</text>
                            
                            <rect x="100" y="60" width="100" height="20" fill="#ef4444" rx="3"/>
                            <text x="150" y="74" textAnchor="middle" fill="white" fontSize="8">Atomic contention</text>
                            
                            <rect x="210" y="60" width="80" height="20" fill="#f59e0b" rx="3"/>
                            <text x="250" y="74" textAnchor="middle" fill="white" fontSize="8">CQ polling</text>
                            
                            <text y="100" fill="#f87171" fontSize="10">
                                Atomic ops and polling evict compute data!
                            </text>
                        </g>
                    </svg>
                </div>
            );
        };

        // Interrupt vs Polling
        const InterruptVsPolling = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">CPU Interrupts vs GPU Polling</div>
                    <svg viewBox="0 0 800 280" style={{width: '100%', maxWidth: '800px', margin: '0 auto', display: 'block'}}>
                        {/* CPU side */}
                        <g transform="translate(50, 30)">
                            <rect width="300" height="220" fill="rgba(59, 130, 246, 0.1)" rx="12" stroke="#3b82f6"/>
                            <text x="150" y="25" textAnchor="middle" fill="#3b82f6" fontWeight="bold" fontSize="14">CPU with Interrupts</text>
                            
                            <g transform="translate(20, 40)">
                                <rect width="260" height="40" fill="#1e293b" rx="6"/>
                                <text x="130" y="25" textAnchor="middle" fill="#93c5fd" fontSize="11">
                                    1. Submit I/O, continue other work
                                </text>
                            </g>
                            
                            <g transform="translate(20, 90)">
                                <rect width="260" height="40" fill="#22c55e" rx="6"/>
                                <text x="130" y="25" textAnchor="middle" fill="white" fontSize="11">
                                    2. MSI-X interrupt on completion
                                </text>
                            </g>
                            
                            <g transform="translate(20, 140)">
                                <rect width="260" height="40" fill="#1e293b" rx="6"/>
                                <text x="130" y="25" textAnchor="middle" fill="#93c5fd" fontSize="11">
                                    3. Handler processes completion
                                </text>
                            </g>
                            
                            <text x="150" y="205" textAnchor="middle" fill="#22c55e" fontSize="10">
                                ‚úì Efficient - CPU does other work while waiting
                            </text>
                        </g>
                        
                        {/* GPU side */}
                        <g transform="translate(450, 30)">
                            <rect width="300" height="220" fill="rgba(239, 68, 68, 0.1)" rx="12" stroke="#ef4444"/>
                            <text x="150" y="25" textAnchor="middle" fill="#ef4444" fontWeight="bold" fontSize="14">GPU with Polling</text>
                            
                            <g transform="translate(20, 40)">
                                <rect width="260" height="40" fill="#1e293b" rx="6"/>
                                <text x="130" y="25" textAnchor="middle" fill="#fca5a5" fontSize="11">
                                    1. Submit I/O
                                </text>
                            </g>
                            
                            <g transform="translate(20, 90)">
                                <rect width="260" height="40" fill="#ef4444" rx="6"/>
                                <text x="130" y="17" textAnchor="middle" fill="white" fontSize="10">
                                    2. Spin-wait polling CQ
                                </text>
                                <text x="130" y="32" textAnchor="middle" fill="white" fontSize="9">
                                    (burning cycles, using memory BW)
                                </text>
                            </g>
                            
                            <g transform="translate(20, 140)">
                                <rect width="260" height="40" fill="#1e293b" rx="6"/>
                                <text x="130" y="25" textAnchor="middle" fill="#fca5a5" fontSize="11">
                                    3. Detect completion via phase bit
                                </text>
                            </g>
                            
                            <text x="150" y="205" textAnchor="middle" fill="#ef4444" fontSize="10">
                                ‚úó Wasteful - GPU burns resources while waiting
                            </text>
                        </g>
                    </svg>
                </div>
            );
        };

        // GDS Architecture
        const GDSArchitecture = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">GPUDirect Storage: Solves Data Path, Not Control Path</div>
                    <svg viewBox="0 0 700 250" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* Components */}
                        <rect x="50" y="50" width="120" height="60" fill="#22c55e" rx="8"/>
                        <text x="110" y="85" textAnchor="middle" fill="white" fontWeight="bold" fontSize="12">GPU Memory</text>
                        
                        <rect x="290" y="50" width="120" height="60" fill="#3b82f6" rx="8"/>
                        <text x="350" y="85" textAnchor="middle" fill="white" fontWeight="bold" fontSize="12">CPU</text>
                        
                        <rect x="530" y="50" width="120" height="60" fill="#a855f7" rx="8"/>
                        <text x="590" y="85" textAnchor="middle" fill="white" fontWeight="bold" fontSize="12">NVMe SSD</text>
                        
                        {/* Data path - direct */}
                        <path d="M 170 80 Q 350 20 530 80" stroke="#22c55e" strokeWidth="4" fill="none"/>
                        <text x="350" y="35" textAnchor="middle" fill="#22c55e" fontSize="11" fontWeight="bold">
                            ‚úì Direct DMA (GDS)
                        </text>
                        
                        {/* Control path - through CPU */}
                        <line x1="170" y1="100" x2="290" y2="100" stroke="#ef4444" strokeWidth="2" strokeDasharray="5,3"/>
                        <line x1="410" y1="100" x2="530" y2="100" stroke="#ef4444" strokeWidth="2" strokeDasharray="5,3"/>
                        <text x="230" y="130" textAnchor="middle" fill="#ef4444" fontSize="10">Control</text>
                        <text x="470" y="130" textAnchor="middle" fill="#ef4444" fontSize="10">Doorbell</text>
                        
                        {/* Legend */}
                        <g transform="translate(100, 170)">
                            <rect width="500" height="60" fill="rgba(15, 23, 42, 0.8)" rx="8"/>
                            <line x1="20" y1="25" x2="80" y2="25" stroke="#22c55e" strokeWidth="4"/>
                            <text x="90" y="30" fill="#22c55e" fontSize="11">Data path (solved by GDS)</text>
                            
                            <line x1="280" y1="25" x2="340" y2="25" stroke="#ef4444" strokeWidth="2" strokeDasharray="5,3"/>
                            <text x="350" y="30" fill="#ef4444" fontSize="11">Control path (still serialized!)</text>
                        </g>
                    </svg>
                </div>
            );
        };

        // Queue Partitioning
        const QueuePartitioning = () => {
            const [strategy, setStrategy] = React.useState('perSM');
            
            const strategies = {
                perSM: { queues: 132, threadsPerQ: 2048, label: '1 Queue per SM' },
                perWarp: { queues: 8448, threadsPerQ: 32, label: '1 Queue per Warp' },
                shared: { queues: 16, threadsPerQ: 16875, label: 'Shared Pool' }
            };
            
            const current = strategies[strategy];
            
            return (
                <div className="diagram-container">
                    <div className="diagram-title">Queue Partitioning Strategies</div>
                    <div style={{display: 'flex', justifyContent: 'center', gap: '1rem', marginBottom: '1.5rem'}}>
                        {Object.entries(strategies).map(([key, val]) => (
                            <button key={key} onClick={() => setStrategy(key)} style={{
                                padding: '0.5rem 1rem', borderRadius: '0.5rem', border: 'none',
                                background: strategy === key ? '#a855f7' : '#334155',
                                color: 'white', cursor: 'pointer', fontSize: '0.85rem'
                            }}>
                                {val.label}
                            </button>
                        ))}
                    </div>
                    
                    <svg viewBox="0 0 600 180" style={{width: '100%', maxWidth: '600px', margin: '0 auto', display: 'block'}}>
                        <text x="300" y="25" textAnchor="middle" fill="white" fontWeight="bold" fontSize="14">
                            {current.label}
                        </text>
                        
                        <g transform="translate(50, 40)">
                            <text fill="#94a3b8" fontSize="11">Queues: <tspan fill="#a855f7" fontWeight="bold">{current.queues.toLocaleString()}</tspan></text>
                            <text y="25" fill="#94a3b8" fontSize="11">Threads/Queue: <tspan fill={current.threadsPerQ > 100 ? '#ef4444' : '#22c55e'} fontWeight="bold">{current.threadsPerQ.toLocaleString()}</tspan></text>
                            <text y="50" fill="#94a3b8" fontSize="11">Serialization: <tspan fill={current.threadsPerQ > 32 ? '#ef4444' : '#22c55e'} fontWeight="bold">{current.threadsPerQ > 32 ? 'HIGH' : 'LOW'}</tspan></text>
                        </g>
                        
                        {/* Visual representation */}
                        <g transform="translate(300, 50)">
                            {strategy === 'perSM' && (
                                <g>
                                    {[...Array(Math.min(current.queues, 20))].map((_, i) => (
                                        <rect key={i} x={(i % 10) * 25} y={Math.floor(i / 10) * 35} 
                                              width="20" height="30" fill="#a855f7" rx="3"/>
                                    ))}
                                    <text x="125" y="90" fill="#64748b" fontSize="9">...{current.queues} queues</text>
                                </g>
                            )}
                            {strategy === 'perWarp' && (
                                <g>
                                    {[...Array(40)].map((_, i) => (
                                        <rect key={i} x={(i % 20) * 12} y={Math.floor(i / 20) * 20}
                                              width="10" height="15" fill="#22c55e" rx="2"/>
                                    ))}
                                    <text x="120" y="60" fill="#64748b" fontSize="9">...{current.queues} queues (ideal but impractical)</text>
                                </g>
                            )}
                            {strategy === 'shared' && (
                                <g>
                                    {[...Array(current.queues)].map((_, i) => (
                                        <rect key={i} x={(i % 8) * 30} y={Math.floor(i / 8) * 40}
                                              width="25" height="35" fill="#ef4444" rx="4"/>
                                    ))}
                                    <text x="120" y="100" fill="#64748b" fontSize="9">Only {current.queues} queues - severe contention!</text>
                                </g>
                            )}
                        </g>
                    </svg>
                    
                    <div className="diagram-caption">
                        {strategy === 'perSM' && 'Moderate contention - 2048 threads compete per queue'}
                        {strategy === 'perWarp' && 'Minimal contention but requires 8000+ queues (often impractical)'}
                        {strategy === 'shared' && 'Severe contention - typical of current deployments'}
                    </div>
                </div>
            );
        };

        // Future Architecture
        const FutureArchitecture = () => {
            return (
                <div className="diagram-container">
                    <div className="diagram-title">Potential Future: GPU-Native NVMe</div>
                    <svg viewBox="0 0 700 220" style={{width: '100%', maxWidth: '700px', margin: '0 auto', display: 'block'}}>
                        {/* Current */}
                        <g transform="translate(50, 30)">
                            <text fill="#ef4444" fontWeight="bold" fontSize="12">Current: Serialized</text>
                            <rect y="20" width="250" height="80" fill="rgba(239, 68, 68, 0.1)" rx="8" stroke="#ef4444"/>
                            
                            <text x="125" y="50" textAnchor="middle" fill="#94a3b8" fontSize="10">32 threads ‚Üí 1 doorbell</text>
                            <text x="125" y="70" textAnchor="middle" fill="#ef4444" fontSize="11">= 32 serial writes</text>
                            <text x="125" y="90" textAnchor="middle" fill="#f87171" fontSize="10">Slowdown: 32x</text>
                        </g>
                        
                        {/* Future */}
                        <g transform="translate(400, 30)">
                            <text fill="#22c55e" fontWeight="bold" fontSize="12">Future: Warp-Aligned</text>
                            <rect y="20" width="250" height="80" fill="rgba(34, 197, 94, 0.1)" rx="8" stroke="#22c55e"/>
                            
                            <text x="125" y="50" textAnchor="middle" fill="#94a3b8" fontSize="10">32 threads ‚Üí batched doorbell</text>
                            <text x="125" y="70" textAnchor="middle" fill="#22c55e" fontSize="11">= 1 combined write</text>
                            <text x="125" y="90" textAnchor="middle" fill="#86efac" fontSize="10">Slowdown: 1x</text>
                        </g>
                        
                        {/* Proposed changes */}
                        <g transform="translate(50, 130)">
                            <text fill="white" fontWeight="bold" fontSize="12">Proposed NVMe Changes:</text>
                            <text y="25" fill="#7dd3fc" fontSize="10">‚Ä¢ Warp-sized queue entries (32 commands)</text>
                            <text y="45" fill="#7dd3fc" fontSize="10">‚Ä¢ Hardware command ID assignment</text>
                            <text y="65" fill="#7dd3fc" fontSize="10">‚Ä¢ Batched doorbell writes</text>
                        </g>
                        
                        <g transform="translate(400, 130)">
                            <text fill="white" fontWeight="bold" fontSize="12">Benefits:</text>
                            <text y="25" fill="#86efac" fontSize="10">‚Ä¢ 32x reduction in doorbell writes</text>
                            <text y="45" fill="#86efac" fontSize="10">‚Ä¢ Eliminate sync overhead</text>
                            <text y="65" fill="#86efac" fontSize="10">‚Ä¢ Full SIMT parallelism preserved</text>
                        </g>
                    </svg>
                </div>
            );
        };

        // Render all components
        ReactDOM.render(<MismatchVisualization />, document.getElementById('mismatch-visualization'));
        ReactDOM.render(<CPUGPUIOComparison />, document.getElementById('cpu-gpu-io-comparison'));
        ReactDOM.render(<QueueContentionDemo />, document.getElementById('queue-contention-demo'));
        ReactDOM.render(<SerializationPointsViz />, document.getElementById('serialization-points-viz'));
        ReactDOM.render(<ThreadSyncSlide />, document.getElementById('thread-sync-slide'));
        ReactDOM.render(<WarpSerializationDemo />, document.getElementById('warp-serialization-demo'));
        ReactDOM.render(<AtomicSerializationViz />, document.getElementById('atomic-serialization-viz'));
        ReactDOM.render(<PerformanceCalculator />, document.getElementById('performance-calculator'));
        ReactDOM.render(<OverheadVisualization />, document.getElementById('overhead-visualization'));
        ReactDOM.render(<InterruptVsPolling />, document.getElementById('interrupt-vs-polling'));
        ReactDOM.render(<GDSArchitecture />, document.getElementById('gds-architecture'));
        ReactDOM.render(<QueuePartitioning />, document.getElementById('queue-partitioning'));
        ReactDOM.render(<FutureArchitecture />, document.getElementById('future-architecture'));
    </script>
</body>
</html>
